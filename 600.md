# 方法一：动态规划
> 方法来源于官方题解，只是对官方题解进行补充便于理解
> 
> 二叉树绘制网址：https://yindongfang.github.io/leetcode/600.html

### 思路

因为正整数 n 可以取到 10^9，所以显然是不可能通过暴力遍历从 1 到 n 的所有正整数来计算答案的。
直观上，我们也可以感觉到，在暴力遍历的过程中，有非常多的计算是重复的。
因此，我们考虑通过优化暴力遍历来解决这个问题。

为了形象地将重复计算的部分找出来，我们不妨将小于等于 n 的非负整数用 01 字典树的形式表示，其中的每一条从根结点到叶结点的路径都是一个小于等于 n 的非负整数（包含前导 0）。

于是，题目可以转化为：在由所有小于等于 n 的非负整数构成的 01 字典树中，找出不包含连续 1 的从根结点到叶结点的路径数量。

以 n = 6 为例：

![image](https://user-images.githubusercontent.com/16241981/132973334-9519ed1f-d82d-46c8-8573-b8c6ada6e3bd.png)

我们发现：

- 对于 01 字典树中的两个节点 n1 和 n2 ，如果它们的高度相同，节点的值也相同，并且以它们为根结点的两棵子树都是满二叉树，那么它们包含的无连续 1 的从根结点到叶结点的路径个数是相同的。

- 对于 01 字典树中的两个结点 n1 和 n2 ，如果 n2 是 n1 的子结点，并且它们的值都是 1，那么所有经过 n1 和 n2 的从根结点到叶结点的路径都一定包含连续的 1。***参考图中红色节点路径***

- 注意到由小于等于 n 的非负整数构成的 01 字典树是完全二叉树。于是有：
如果某个结点包含两个子结点，那么其左子结点为根结点是 0 的满二叉树，其右子结点为根结点是 1 的完全二叉树；
如果某个结点只有一个子结点，那么其左子结点为根结点是 0 的完全二叉树。
***官方举例 n = 6 的情况符合该描述，但是严格来讲，右子节点并不一定是完全二叉树，可以参考下图 n = 12 的情况***

![image](https://user-images.githubusercontent.com/16241981/132973531-98a8b8ed-02b3-4414-8f02-a660f9960944.png)

我们在计算不包含连续 1 的从根结点到叶结点的路径数量时，可以不断地将字典树拆分为根结点为 0 的满二叉树和根结点不定的完全二叉树。
***参考上述第三点，这里严格来讲是：根节点为 0 的满二叉树和根节点为 1 的二叉树***

于是，题目被拆分为以下两个子问题：

问题 1：如何计算根结点为 0 的满二叉树中，不包含连续 1 的从根结点到叶结点的路径数量。
问题 2：如何将将字典树拆分为根结点为 0 的满二叉树和 **~~根结点不定的完全二叉树~~** 根节点为 1 的二叉树。

### 算法

首先解决第 1 个问题。

我们发现，在高度为 t、根结点为 0 的满二叉树中：其左子结点是高度为 t-1、根结点为 0 的满二叉树。其右子结点是高度为 t-1、根结点为 1 的满二叉树；
但是因为路径中不能有连续 1，所以右子结点下只有其左子结点包含的从根结点到叶结点的路径才符合要求，而其左子结点是高度为 t−2、根结点为 0 的满二叉树。

于是，高度为 t、根结点为 0 的满二叉树中不包含连续 1 的从根结点到叶结点的路径数量，等于高度为 t-1、根结点为 0 的满二叉树中的路径数量与高度为 t−2，根结点为 0 的满二叉树中的路径数量之和。

如图所示：

方框中为：高度为 t、根结点为 0 的满二叉树，其符合条件的路径数量 = 第 1 部分路径数量 + 第 2 部分路径数量

![image](https://user-images.githubusercontent.com/16241981/132973693-04506000-cf1c-47c3-b72b-cfc6a37813aa.png)

因此，这个问题可以通过动态规划解决：

![image](https://user-images.githubusercontent.com/16241981/132973735-43f961d5-cad4-4721-84c9-0ed757291630.png)

接着解决第 2 个问题。

我们可以从根结点开始处理。如果当前结点包含两个子结点，则用问题 1 的解决方法计算其左子结点中不包含连续 1 的从根结点到叶结点的路径数量，并继续处理其右子结点；
如果当前结点只包含一个左子结点，那么只需要处理其左子结点。

在实现中，需要注意如果已经出现连续 1 则不用继续处理；另外，叶结点没有子结点，需要作为特殊情况单独处理。

### 代码

```javascript
var findIntegers = function(n) {
    // n 最大为 10^9，转换为 2 进制最多 30 位，先计算出各深度左节点满二叉树的路径数
    const dp = new Array(31).fill(0);
    dp[0] = dp[1] = 1;
    for (let i = 2; i < 31; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    // pre 记录上一节点，也就是父节点的值，用于判定是否为连续两位 1
    // res 记录路径数之和，及结果
    let pre = 0, res = 0;
    for (let i = 29; i >= 0; --i) {
        // 判定 n 的二进制第 i 位是否为 1，相当于从 01 二叉树根节点向下遍历
        let val = 1 << i;
        // 如果当前位的值为 1，则该节点下会有 0 为根节点的满二叉树作为左子树和 1 为根节点的右子树
        if ((n & val) !== 0) {
            // 加上左子树的路径数
            res += dp[i + 1];
            // 如果父节点为 1，则该子树下的所有路径都为无效路径，直接结束循环
            if (pre === 1) {
                break;
            }
            // 记录节点值
            pre = 1;
        } 
        // 如果当前位为 0，则只包含左子树，记录 pre 值，然后进入下一个循环处理其子树
        else {
            pre = 0;
        }
        // 遍历到叶子节点，加上当前路径
        if (i === 0) {
            ++res;
        }
    }

    return res;
};
```
